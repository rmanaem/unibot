Artificial Intelligence:  State Space Search    Many slides from:  robotics.stanford.edu/~latombe/cs121/2003/home.htm 1 BreakPage Motivation Google itinerary 8-puzzle Rubik’s cube Tetris 22 BreakPage Today  State Space Representation Agent Perception  State Space Search Robotics  Uninformed search  Breadth-first and Depth-first Reasoning  Depth-limited Search  Search Learning  Iterative Deepening  Uniform Cost  Informed search  Knowledge Constraint Planning rep. satisfaction     Hill climbing  Best-First  (Designing Heuristics) Natural  A* ... Expert language  Summary Systems 3 BreakPage Example: 8-Puzzle State: Any arrangement of 8 numbered tiles and an empty tile on a 3x3 board 8 2 1 2 3 3 4 7 4 5 6 5 1 6 7 8 Initial state Goal state there are several standard goals states for the 8-puzzle 1 2 3 1 2 3 … 4 5 6 8 4 7 8 7 6 5 4 BreakPage (n2-1)-puzzle 8 2 1 2 3 4 .... 3 4 7 5 6 7 8 5 1 6 9 10 11 12 13 14 15 8-puzzle 15-puzzle 5 BreakPage 15-Puzzle Invented in 1874 by Noyes Palmer Chapman   … but Sam Loyd claimed he invented it! 6 BreakPage 15-Puzzle Sam Loyd even offered $1,000 of his own  money to the first person who would solve the  following problem: 1 2 3 4 1 2 3 4 5 6 7 8 5 6 7 8 ? 9 10 11 12 9 10 11 12 13 14 15 13 15 14 7 BreakPage But no one ever won the prize… 8 BreakPage State Space  Many AI problems, can be expressed in terms of going  from an initial state to a goal state  Ex: to solve a puzzle, to drive from home to Concordia…  Often, there is no direct way to find a solution to a  problem  but we can list the possibilities and search through them Brute force search:  1.  generate and search all possibilities (but inefficient) Heuristic search:  2.  only try the possibilities that you think (based on your  current best guess) are more likely to lead to good solutions 9 BreakPage State Space  Problem is represented by: Initial State 1.  starting state   ex. unsolved puzzle, being at home Set of operators 2.  actions responsible for transition between states Goal test function 3.  Applied to a state to determine if it is a goal state  ex. solved puzzle, being at Concordia Path cost function 4.  Assigns a cost to a path to tell if a path is preferable to  another  Search space: the set of all states that can be reached  from the initial state by any sequence of action  Search algorithm:  how the search space is visited 10 BreakPage Example: The 8-puzzle 8 2 1 2 3 3 4 7 4 5 6 5 1 6 7 8 Initial state Goal state Set of operators:  blank moves up, blank moves down, blank moves left, blank moves right  Goal test function: state matches the goal state Path cost function: each movement costs 1 so the path cost is the length of the path (the number of moves) source: G. Luger (2005)  11 BreakPage 8-Puzzle: Successor Function 8 2 7 3 4 5 1 6 8 2 8 2 7 8 2 7 3 4 7 3 4 6 3 4 5 1 6 5 1 5 1 6 Search is about the exploration of alternatives 12 BreakPage State Graph  Each state is  represented by a  distinct node    An arc (or edge)  connects a node s  to a node s’ if  s’ ∈ SUCCESSOR(s)    The state graph may  contain more than one  connected component 13 BreakPage Just to make sure we’re clear… 5 8 1 2 3 4 2 1 4 5 6 7 3 6 7 8 14 Initial state Goal state BreakPage State Space as a Search Tree  In graph representation, cycles can prevent  termination  Blind search without cycle check may never  Search tree terminate  Use a tree representation, and check for cycles 15 BreakPage State Space for the 8-puzzle Right Up Left Down source: G. Luger (2005)  16 BreakPage How large is the state space of the  (n2-1)-puzzle?  Nb of states:  8-puzzle  -->  9! = 362,880 states  15-puzzle  -->  16! ~ 2.09 x 1013 states  24-puzzle  -->  25! ~ 1025 states  At 100 millions states/sec:  8-puzzle --> 0.036 sec  15-puzzle --> ~ 55 hours  24-puzzle  -->  > 109 years 17 BreakPage Today  State Space Representation  State Space Search  Uninformed search  Breadth-first and Depth-first  Depth-limited Search   Iterative Deepening  Uniform Cost  Informed search   Hill climbing  Best-First  (Designing Heuristics)  A*  Summary 18 BreakPage Uninformed VS Informed Search   Uninformed search   We systematically explore the alternatives  aka: systematic/exhaustive/blind/brute force search  Breadth-first  Depth-first  Uniform-cost  Depth-limited search  Iterative deepening search  Bidirectional search   …  Informed search (heuristic search)  We try to choose smartly  Hill climbing  Best-First  A*  … 19 BreakPage Today  State Space Representation  State Space Search  Uninformed search  Breadth-first and Depth-first  Depth-limited Search   Iterative Deepening  Uniform Cost  Informed search   Hill climbing  Best-First  (Designing Heuristics)  A*  Summary 20 BreakPage Breadth-first vs Depth-first Search  Determine order for examining states  Depth-first:  visit successors before siblings  Breadth-first:  visit siblings before successors   ie. visit level-by-level source: G. Luger (2005)  21 BreakPage Data Structures  In all search strategies, you need:   open list (aka the frontier)  lists generated nodes not yet expanded  order of nodes controls order of search   closed list (aka the explored set)  stores all the nodes that have already been visited (to avoid cycles).  ex: Closed = [A, B, C, D, E] Open = [F, G, H, I, J, K, L] source: G. Luger (2005)  22 BreakPage Data Structures  To trace back the entire path of the solution after  the search, each node in the lists contain:  STATE  PARENT-NODE 8 2 REPRESENTATION 3 4 7 5 1 6 BOOKKEEPING Action Right CHILDREN Depth 5 ... Path-Cost 5 Depth = length of path from root to node  23 BreakPage Generic Search Algorithm  1. Initialize the open list  with the initial node s  (top node)  o 2. Initialize the closed list   to  empty 3. Repeat a) If the open list  is empty, then exit with failure. b) Else, take the first node s  from the open list.  c) If s is a goal state, exit  with success.  Extract the solution path  from s to s o d) Else, insert s in the closed list (s has been visited /expanded)  e) Insert the successors of s  in  the  open list  in a certain order if  they are not already in the closed and/or open lists (to avoid  cycles)   Notes:     The order of the nodes in the open list depends on the search  strategy 24 BreakPage DFS and BFS  DFS and BFS differ only in the way they order nodes in the  open list:   DFS uses a stack:      nodes are added on the top of the list.   BFS uses a queue:    nodes are added at the end of the list. 25 BreakPage Breadth-First Search source: G. Luger (2005)  26 BreakPage Breadth-First Search Example  BFS: (open is a queue) Assume U is goal state 1. open = [A ]  closed = [] -null 2. open = [B   C  D ]  closed [A] -A -A  -A 3. open = [C  D E  F ]  closed = [B A] -A -A   -B -B 4. → Worksheet #1 (“Breadth-First Search”) ...and so on until either U is found or open = [] source: G. Luger (2005)  27 BreakPage Snapshot of BFS  Search graph at  iteration 6 of  breadth-first  search  States on open  and closed are  highlighted source: G. Luger (2005)  29 BreakPage Function Depth-First Search source: G. Luger (2005)  30 BreakPage Depth-First Search Example  DFS: (open is a stack) Assume U is goal state 1. open = [A ]  closed = [] -null 2. open = [B   C  D ]  closed [A] -A -A  -A 3. open = [E  F  C  D ]  closed = [B A] -B -B -A -A 4. open = [K  L F  C  D ]  closed = [E B A] -E -E  -B -A -A 5. open = [S  L  F  C  D ]  closed = [K E B A] -K -E -B -A -A → Worksheet #1 (“Depth-First Search”) source: G. Luger (2005)  31 BreakPage Snapshot of DFS  Search graph at  iteration 6 of  depth-first  search  States on open  and closed are  highlighted source: G. Luger (2005)  33 BreakPage Depth-first vs. Breadth-first  Breadth-first:  Optimal: will always finds shortest path But:  inefficient if branching factor B is very high  memory requirements high -- exponential space for states  required: Bn  Depth-first:  Not optimal (no guarantee to find the shortest path) But:  Requires less memory  But both search are impractical in real applications  because search space is too large! 34 BreakPage Today  State Space Representation  State Space Search  Uninformed search  Breadth-first and Depth-first  Depth-limited Search   Iterative Deepening  Uniform Cost  Informed search   Hill climbing  Best-First  (Designing Heuristics)  A*  Summary 35 BreakPage Depth-Limited Search Compromise for DFS :  Do depth-first but with depth cutoff k (depth  at which nodes are not expanded)  Three possible outcomes:  Solution  Failure (no solution)  Cutoff (no solution within cutoff) 36 BreakPage Today  State Space Representation  State Space Search  Uninformed search  Breath-first and Depth-first  Depth-limited Search   Iterative Deepening  Uniform Cost  Informed search   Hill climbing  Best-First  (Designing Heuristics)  A*  Summary 37 BreakPage Iterative Deepening Compromise between BFS and DFS:  use depth-first search, but  with a maximum depth before going to next level  Repeats depth first search with gradually increasing  depth limits  Requires little memory (fundamentally, it’s a depth first)  Finds the shortest path (limited depth)  Preferred search method when there is a large search  space and the depth of the solution is unknown  38 BreakPage Iterative Deepening: Example source: Russel & Norvig (2003)  39 BreakPage Iterative Deepening: Example source: Russel & Norvig (2003)  40 BreakPage Iterative Deepening: Example source: Russel & Norvig (2003)  41 BreakPage Iterative Deepening: Example source: Russel & Norvig (2003)  42 BreakPage Today  State Space Representation  State Space Search  Uninformed search  Breath-first and Depth-first  Depth-limited Search   Iterative Deepening  Uniform Cost  Informed search   Hill climbing  Best-First  (Designing Heuristics)  A*  Summary 43 BreakPage Uniform Cost Search  Breadth First Search   Open is a priority queue sorted using the depth of the nodes from  the root  guarantees to find the shortest solution path  But what if all edges/moves do not have the same cost?  Uniform Cost Search 4 3  uses a priority queue sorted using  2 the cost from the root to node n –  later called g(n) 6 3  guarantees to find the lowest cost  solution path 44 BreakPage Today  State Space Representation  State Space Search  Uninformed search  Breath-first and Depth-first  Depth-limited Search   Iterative Deepening  Uniform Cost  Informed search   Hill climbing  Best-First  (Designing Heuristics)  A*  Summary 45 BreakPage Informed Search  (aka heuristic search)  Most of the time, it is not feasible to do an exhaustive search,  search space is too large  e.g. state space of all possible moves in chess = 10120   1075 = nb of molecules in the universe  1026 = nb of nanoseconds since the “big bang”  so far, all search algorithms have been uninformed (general  search)  so need an informed/heuristic search    Idea:   choose "best" next node to expand  according to a selection function (i.e. a heuristic function h(n))  But: heuristic might fail  46 BreakPage Heuristic - Heureka!   Heuristic:   a rule of thumb, a good bet  but has no guarantee to be correct whatsoever!  Heuristic search:  A technique that improves the efficiency of search,  possibly sacrificing on completeness  Focus on paths that seem most promising according to  some function  Need an evaluation function (heuristic function) to  score a node in the search tree  Heuristic function h(n) = an approximation of the  lowest cost from node n to the goal 47 BreakPage g(n) 4 3 2 6 3 2 1  g(n) = cost of current path from start to node n 48 BreakPage h(n) 3 6 2  h(n) = estimate of the lowest cost from n to goal 49 BreakPage Today  State Space Representation  State Space Search  Uninformed search  Breath-first and Depth-first  Depth-limited Search   Iterative Deepening  Informed search   Hill Climbing  Best-First  (Designing Heuristics)  A*  Summary 50 BreakPage Example: Hill Climbing with Blocks World  Operators:  pickup&putOnTable(Block)  pickup&stack(Block1,Block2)  Heuristic:  0pt if a block is sitting where it is supposed to sit  +1pt if a block is NOT sitting where it is supposed to sit  so lower h(n) is better  h(initial) = 2  h(goal) = 0 source: Rich & Knight, Artificial Intelligence, McGraw-Hill College 1991.   51 BreakPage Example: Hill Climbing with Blocks World h(n) = 2 pickup&putOnTable(A) h(n) = 1 pickup&stack(A,H) pickup&putOnTable(H) pickup&stack(H,A) h(n) = 2 h(n) = 2 h(n) = 2 52 BreakPage Hill Climbing  General hill climbing strategy:   as soon as you find a position that is better than the  current one, select it.   Does not maintain a list of next nodes to visit (an open list)  Similar to climbing a mountain in the fog with amnesia …  always go higher than where you are now,  help!        but never go back…  Steepest ascent hill climbing:  instead of moving to the first position that       is better than the current one  pick the best position out of all the next possible moves  53 BreakPage Steepest Ascent Hill Climbing currentNode = startNode;      loop do          L = CHILDREN(currentNode);          nextEval = INFINITY;          nextNode = NULL;          for all c in L              if (HEURISTIC-VALUE(c) < nextEval) // lower h is better                  nextNode = c;                  nextEval = HEURISTIC-VALUE(c);          if nextEval >= HEURISTIC-VALUE(currentNode)             // Return current node since no better child state exists             return currentNode;          currentNode = nextNode; Adapted from https://en.wikipedia.org/wiki/Hill_climbing 54 BreakPage Example: Hill Climbing with Blocks World h(n) = 2 hill-climbing will stop, pickup&putOnTable(A) because all children have higher h(n) than the parent… --> local minimum h(n) = 1 pickup&stack(A,H) pickup&putOnTable(H) pickup&stack(H,A) Don’t be confused…  a lower h(n) is better… h(n) = 2 h(n) = 2 h(n) = 2 55 BreakPage Problems with Hill Climbing   Foothills (or local maxima)   reached a local maximum, not the global maximum  a state that is better than all its neighbors but is not better  than some other states farther away.   at a local maximum, all moves appear to make things worse.    ex: 8-puzzle: we may need to move tiles temporarily out of goal  position in order to place another tile in goal position  ex: TSP: "nearest neighbour" heuristic n n t   e s e p r e h(n)  o   r e r   t t e m a a r p e r   h o t e   m o S Some parameter to represent n 56 BreakPage Problems with Hill Climbing   Plateau  a flat area of the search space in which the next states  have the same value.   it is not possible to determine the best direction in which  to move by making local comparisons.  source: Rich & Knight, Artificial Intelligence, McGraw-Hill College 1991.  57 BreakPage Some Solutions to Hill-Climbing    Random-restart hill-climbing   random initial states are generated  run each until it halts or makes no significant progress.   the best result is then chosen.  keep going even if the best successor has the same value as  current node  works well on a "shoulder"  but could lead to infinite loop      on a plateau source: Rich & Knight, Artificial Intelligence, McGraw-Hill College 1991. & Russel & Norvig (2003)  58 BreakPage Today  State Space Representation  State Space Search  Uninformed search  Breadth-first and Depth-first  Depth-limited Search   Iterative Deepening  Informed search   Hill Climbing  Best-First  (Designing Heuristics)  A*  Summary 59 BreakPage Best-First Search  problem with hill-climbing:  one move is selected and all others are forgotten.  solution to hill-climbing:   use "open" as a priority queue  this is called best-first search  Best-first search:  Insert nodes in open list so that the nodes are sorted in  ascending  h(n)  Always choose the next node to visit to be the one with the  best h(n) -- regardless of where it is in the search space 60 BreakPage Best-First: Example Lower h(n) is better source: Rich & Knight, Artificial Intelligence, McGraw-Hill College 1991.   61 BreakPage Notes on Best-first  If you have a good h(n), best-first can find the  solution very quickly  The first solution may not be the best,  but there is a good chance of finding it quickly  It is an exhaustive search …  will eventually try all possible paths 62 BreakPage Best-First Search: Example 1. open = [A ]  closed = [] -null-5 2. open = [B  C  D ]   closed [A] -A-4  -A-4  -A-6 (arbitrary choice)  3. open = [C E F D ]  closed = [B A] -A-4  -B-5  -B-5   -A-6 4. → Worksheet #1 (“Best-First Search”) Lower h(n) is better P-0 source: adapted from G. Luger (2005)  63 BreakPage Today  State Space Representation  State Space Search  Uninformed search  Breadth-first and Depth-first  Depth-limited Search   Iterative Deepening  Informed search   Hill Climbing  Best-First  (Designing Heuristics)  A*  Summary 65 BreakPage Designing Heuristics  Heuristic evaluation functions are highly dependent on the search domain  In general: the more informed a heuristic is, the better the search performance  Bad heuristics lead to frequent backtracking  So how do we design a “good” heuristic? 66 BreakPage Example: 8-Puzzle – Heuristic 1  h : Simplest heuristic 1  Hamming distance : count  number of tiles out of place  when compared with goal 5 8 1 2 3 4 2 1 4 5 6 7 3 6 7 8 STATE n Goal state  h (n)  = 6 1  does not consider the  distance tiles have to be  moved source: G. Luger (2005)  67 BreakPage Example: 8-Puzzle – Heuristic 2  h : Better heuristic 2  Manhattan distance: sum up  all the distances by which  tiles are out of place 5 8 1 2 3 4 2 1 4 5 6 7 3 6 7 8 STATE n Goal state  h (n) = 2+3+0+1+3+0+3+1  2              = 13 source: G. Luger (2005)  68 BreakPage Example: 8-Puzzle – Heuristic 3  h : Even Better 3  sum of permutation  inversions  See next slide… source: G. Luger (2005)  69 BreakPage h (N) = sum of permutation inversions 3 5 8 5 8 4 2 1 7 3 6 4 2 1 7 3 6 STATE n  For each numbered tile, count how many tiles on its right  should be on its left in the goal state.   1 2 3  h (n) = n  + n  + n  + n  + n  + n  + n  + n 4 5 6 3 5 8 4 2 1 7 3 6    = 4  + 6  + 3   + 1   + 0  + 2   + 0  + 0  7 8    = 16  Goal state 70 BreakPage Heuristics for the 8-Puzzle 5 8 1 2 3 4 2 1 4 5 6 7 3 6 7 8 STATE n Goal state  h (n)  = misplaced numbered tiles  1               = 6  h (n)  =  Manhattan distance  2           = 2 + 3 + 0 + 1 + 3 + 0 + 3 + 1 = 13  h (n) = sum of permutation inversions 3         = n  + n  + n   + n  + n  + n  + n  + n 5 8 4 2 1 7 3 6   = 4  + 6  + 3   + 1   + 0  + 2  + 0  + 0  = 16 71 BreakPage g(n), h(n) and f(n)  Evaluation function f(n) = g(n) + h(n) for node n:  g(n) current cost from start to node n  h(n) estimate of the lowest cost from n to goal  f(n) estimate of the lowest cost of the solution  path (from start to goal passing through n)  Now consider f*(n) = g*(n) + h*(n):  g*(n) cost of lowest cost path from start to  node n  h*(n) actual lowest cost from n to goal  f*(n) actual cost of lowest cost of the solution  path (from start to goal passing through n) 72 BreakPage Evaluating Heuristics Admissibility: 1.  “optimistic”  never overestimates the actual cost of reaching the goal  guarantees to find the lowest cost solution path to the goal (if it  exists) Monotonicity: 2.  “local admissibility”  guarantees to find the lowest cost path to each state n encountered  in the search Informedness: 3.  measure for the “quality” of a heuristic  the more informed, the better 73 BreakPage Admissibility  A heuristic is admissible if it never overestimates the  cost of reaching the goal  i.e.:  h(n) ≤ h*(n)  for all n  guarantees to find the lowest cost solution path to the  goal (if it exists)  Note:  does not guarantee to find the lowest cost search  path.   e.g.: breadth-first is admissible  -- it uses f(n) = g(n) + 0  74 BreakPage Example: 8-Puzzle 5 8 1 2 3 4 2 1 4 5 6 7 3 6 7 8 goal n   h1(n) = Hamming distance = number of misplaced tiles = 6  --> admissible   h2(n) = Manhattan distance = 13  --> admissible 75 BreakPage Monotonicity  (aka consistent)  An admissible heuristics may temporarily reach non-goal states  along a suboptimal path  A heuristic is monotonic if it always finds the optimal path to  each state the 1st time it is encountered !  guarantees to find the lowest cost path to each state n  encountered in the search  h is monotonic if for every node n and every successor n’ of n:  h(n) ≤ c(n,n') + h(n')  i.e. f(n) is non-decreasing along any path 76 BreakPage Informedness  Intuition: number of misplaced tiles is less informed than  Manhattan distance   For two admissible heuristics h  and h 1 2  if h (n) ≤ h (n), for all states n 1 2  then h  is more informed than h 2 1  h (n) ≤ h (n) ≤ h*(n)  1 2 More informed heuristics search smaller space to find the  solution path  However, you need to consider the computational cost of  evaluating the heuristic…  The time spent computing heuristics must be recovered  by a better search 77 BreakPage Today  State Space Representation  State Space Search  Uninformed search  Breadth-first and Depth-first  Depth-limited Search   Iterative Deepening  Informed search   Hill Climbing  Best-First  (Designing Heuristics)  A*  Summary 78 BreakPage Algorithm A  Heuristics might be wrong:  so search could continue down a wrong path  Solution:  Maintain depth/cost count, i.e., give preference to  shorter/least expensive paths  Modified evaluation function f:  f(n) = g(n) + h(n)   f(n) estimate of total cost along path through n  g(n) actual cost of path from start to node n  h(n) estimate of cost to reach goal from node n  79 BreakPage Algorithm A on the 8-puzzle → Worksheet #1 (“Algorithm A”) source: G. Luger (2005)  80 BreakPage Algorithm A on the 8-puzzle source: G. Luger (2005)  82 BreakPage Algorithm A on the 8-puzzle source: G. Luger (2005)  83 BreakPage BFS vs.  Heuristic search (tiles out of place) source: G. Luger (2005)  BreakPage Algorithm A vs Algorithm A*  if g(n) ≥ g*(n) for all n  best-first used with such a g(n) is called “algorithm A”  if h(n) ≤ h*(n) for all n  i.e. h(n) never overestimates the true cost from n to a goal  algorithm A used with such an h(n) is called “algorithm A*”  an A* algorithm is admissible   i.e. it guarantees to find the lowest cost solution path  from the initial state to the goal 85 BreakPage Today  State Space Representation  State Space Search  Uninformed search  Breath-first and Depth-first  Depth-limited Search   Iterative Deepening  Informed search   Hill climbing  Best-First  (Designing Heuristics)  A*  Summary 86 BreakPage Summary Search Uses h(n)? Open is a… Breadth-first No Queue Depth-first No Stack Depth-limited No Stack Iterative Deepening No Stack Uniform Cost No Priority queue sorted by g(n) Hill Climbing Yes none Best-First Yes Priority queue sorted by h(n) Algorithm A Yes Priority queue sorted by f(n)  - no constraints on h(n) f(n) = g(n) + h(n)  Algorithm A* Yes Priority queue sorted by f(n)  - same as A, but h(n) must be  f(n) = g(n) + h(n)  admissible - guarantees to find the lowest  cost solution path 87 BreakPage Today  State Space Representation  State Space Search  Uninformed search  Breadth-first and Depth-first  Depth-limited Search   Iterative Deepening  Uniform Cost  Informed search   Hill climbing  Best-First  A*  Summary 88 BreakPage 